\documentclass[../ClassicThesis.tex]{subfiles}
\begin{document}

%************************************************
\chapter{Plates}\label{ch:plates}
%************************************************

\section{Overview of approaches for finding plates}

There are multiple approaches for finding plates contained in a 3D-mesh. The first, called inherent plates, requires the plates to be actually modeled in the mesh with both a top and a bottom side. The second approach, extruded plates, uses the mesh surface to extrude plates into the object. While this method works on more meshes then the inherent approach, it can produce doubled plates if they are modeled in the mesh. The third approach is to stack plates, creating a filled approximation of the mesh.

\section{Prerequisites for finding plates}

coplanar / shapesfinder / holedetection

\subsection{Coplanar Faces}

The algorithm for finding coplanar faces requires the models to be stored as a face-vertex mesh. This is calculated by Meshlib, the library used for importing models. In a face-vertex mesh, faces only store their vertices' indices, with the vertices being stored in a different lookup table. This allows for easier adjacency checks - only the vertex indices have to be compared. Additionally, the face normals are stored in an array, in the same order as in the face list.

Now, two more lookup tables are added: One contains all edges (stored as a sorted pair of vertex indices) belonging to each face, while the second one allows looking up the faces adjacent to an edge. Both lists can be created in one single pass. 

\begin{listing}[ht]
\begin{minted}[
linenos
]{coffeescript}
setupFaceEdgeEdgeFaceLookup: ->
  for faceIndex in [0...faceCount]
    # Determine the ordering of vertices (this avoids double edges)
    { min_vertex
      mid_vertex
      max_vertex } = @findMinMidMaxVertex()
    # Register which edges this triangle uses.
    @addEntryToEdgeFaceMap(min_vertex, mid_vertex, faceIndex)
    @addEntryToEdgeFaceMap(mid_vertex, max_vertex, faceIndex)
    @addEntryToEdgeFaceMap(min_vertex, max_vertex, faceIndex)
    # Set the edges that make up this triangle.
    @faceVertexMesh.faceToEdges[faceIndex] = [
      [min_vertex, mid_vertex]
      [mid_vertex, max_vertex]
      [min_vertex, max_vertex]
    ]
\end{minted}
\caption{Simplified lookup table generation.}
\label{lst:coffeescript}
\end{listing}

Afterward, the faces are grouped. This in done by iterating over all faces. When a face is found which hasn't been visited yet, a new face group is started. Now all of the face's edges are pushed to a queue, along with the current face index.

\begin{listing}[ht]
\begin{minted}[
linenos
]{coffeescript}
for faceIndex in [0...faceCount] when not faceVisited[faceIndex]
  faceGroup = [faceIndex]
  faceGroupIndex = faceGroups.length
  outerEdgeGroup = []
  groupNormal = @faceVertexMesh.getFaceNormal(faceIndex)
  faceVisited[faceIndex] = true
  # connect the adjacent faces
  edgeQueue = []
  adjacentEdges = @faceVertexMesh.getEdgesFromFace(faceIndex)
  for edge in adjacentEdges
    edgeQueue.push({ edge, faceIndex })
  @traverseAdjacentFaces(...)
\end{minted}
\caption{Iteration over faces with creation of new face groups.}
\label{lst:coffeescript}
\end{listing}

There are multiple important variables being set here: First, we have the new face group, containing only the current face. Next, we have the index of the face group, used for creating a face to face group lookup table. The outerEdgeGroup contains all edges surrounding the group, wich allows the creation of a shape containing the face group. The group's normal vector is initialized with the current face's normal vector. Lastly, the current face is marked as visited in order to avoid checking it multiple times.

After the edges have been pushed in the queue, we start working on the it:

\begin{listing}[ht]
\begin{minted}[
linenos
]{coffeescript}
traverseAdjacentFaces: tco (
    edgeQueue,
    faceVisited,
    faceGroup,
    faceGroupIndex,
    outerEdgeGroup,
    groupNormal
  ) ->
    if edgeQueue.length is 0
      return

    { edge, faceIndex } = edgeQueue.shift()
    faceNormal = @faceVertexMesh.getFaceNormal(faceIndex)

    # get the faces from the edge and choose the one thats not the current one
    adjacentFaces = @faceVertexMesh.getFacesFromEdge(
      edge[0]
      edge[1]
    )

    nextFaceIndex =
      if adjacentFaces[0] is faceIndex
      then adjacentFaces[1]
      else adjacentFaces[0]
    nextFaceNormal = @faceVertexMesh.getFaceNormal(nextFaceIndex)

    if @isAngleZero(faceNormal, nextFaceNormal)
      if not faceVisited[nextFaceIndex]
      # if the adjacent face is coplanar and wasn't visited yet
      # add to group, mark as visited, check adjacent faces
        faceGroup.push(nextFaceIndex)
        groupNormal.add(nextFaceNormal)
        @faceToFaceGroup[nextFaceIndex] = faceGroupIndex
        faceVisited[nextFaceIndex] = true

        adjacentEdges = @faceVertexMesh.getEdgesFromFace(nextFaceIndex)
        for edge in adjacentEdges
          edgeQueue.push({ edge, faceIndex: nextFaceIndex })
    else
      # the edge is an outer edge for this coplanar group
      # in that case, don't check if the face was already visited
      outerEdgeGroup.push(edge)

    @recur(
      edgeQueue
      faceVisited
      faceGroup
      faceGroupIndex
      outerEdgeGroup
      groupNormal
    )
\end{minted}
\caption{Iteration over faces with creation of new face groups.}
\label{lst:coffeescript}
\end{listing}

\subsection{Shape Finder / Deus}



\subsection{Hole Detection / Dimitri}

sdfjkljklsdfsdfjkl

\section{Finding inherent plates}

In order to find inherent plates in a mesh, the first step is to find all shapes which are parallel and check if the distance between them fits one of the given plate thicknesses.

\begin{listing}[ht]
\begin{minted}[
linenos
]{coffeescript}
candidates = []
for shape1, index1 in shapes
    for shape2, index2 in shapes when index1 < index2
        if normals parallel and surfaces facing apart
            if distance between shape1, shape2 in plate thicknesses
                candidates.push { shape1, shape2 }
return candidates
\end{minted}
\caption{Plate candidate pseudo code.}
\label{lst:coffeescript}
\end{listing}

While the testing for normal parallelism is done with built-in vector functions, the check if the surfaces are facing apart uses a vertex of each of the surfaces and calculates the angle of the resulting vector to one of the normals. If this angle is smaller than 90\textdegree, the surfaces are indeed facing apart. The distance between the surfaces is calculated by creating a three.js plane from one of the shapes and computing the plane-to-point distance towards one of the other shape's points.

After finding these plate candidates, the shapes which plane's distance to the origin (the z-value of all vertices when laid into the x-y-plane) is smaller is selected as the base shape of the plate. Now, the intersection of both shapes is calculated. This is done by using the already calculated mapping of vertices into the x-y-plane. The resulting intersection is transformed back into 3D-space using the rotation matrix of the base shape. With the resulting shapes, plates are created.

% \begin{center}Listing XYZ: Plate creation
% \begin{lstlisting}
% shape2CloserToOrigin = abs(shape2.zValue) < abs(shape1.zValue)
% polygon1 = create2DPolygon(shape1)
% polygon2 = create2DPolygon(shape2)
% intersection = polygon1.intersect polygon2
% shapes = parseToShapes(intersection)
% plates = parseToPlates(shapes)
% return plates
% \end{lstlisting}
% \end{center}

This step uses the jsclipper library for intersecting the shapes. After parsing them into the library's polygon class, they can be easily clipped, resulting in a list of intersections which can be parsed back into shapes. The plate creation is based on the previously selected base shape. While the calculated intersection is used as the shape of the plate, the thickness is computed by subtracting the base shape's z-value from the other shape's z-value. Additionally, the base shape's z-value is used as plane constant.

\section{Extruding plates}

blabla

\section{Removing contained plates / Dimitri}

dfgdfgdfgdfgdfg

\section{Stacking plates}

blablabla

% Hey Lukas hier ist Klara, habe eine alternative methode für algorithms darstellen, die finde ich persönlich übersichtlicher.
% HIer ein Beispiel:
% \begin{algorithm}[H]
% \DontPrintSemicolon
% 	\KwData{this text}
% 	\KwResult{how to write algorithm with \LaTeX2e }
% 	initialization\;
% 	\While{not at end of this document}{
% 	read current\;
% 	\eIf{understand}{
% 	go to next section\;
% 	current section becomes this one\;
% 	}{
% 	go back to the beginning of current section\;
% 	}
%      \For{all I know}{
%      look at this link to learn more about \LaTeX2e:\;
%      http://ctan.space-pro.be/tex-archive/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf\;
%      }
% 	}
%    \caption{How to write algorithms}
% Kannst ja mal überlegen, wir sollten uns aber auf eins von beiden einigen

% \end{algorithm}

\end{document}